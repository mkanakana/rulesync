import { afterEach, beforeEach, describe, expect, it, vi } from "vitest";
import { Config } from "../../config/config.js";
import { ConfigResolver } from "../../config/config-resolver.js";
import type { RulesyncFeatures } from "../../types/features.js";
import type { RulesyncTargets } from "../../types/tool-targets.js";
import { fileExists, readFileContent, writeFileContent } from "../../utils/file.js";
import { logger } from "../../utils/logger.js";
import { gitignoreCommand } from "./gitignore.js";

vi.mock("../../utils/file.js");
vi.mock("../../utils/logger.js");
vi.mock("../../config/config-resolver.js");

const createMockConfig = ({
  targets = ["*"],
  features = ["*"],
  modularMcp = false,
}: {
  targets?: RulesyncTargets;
  features?: RulesyncFeatures;
  modularMcp?: boolean;
} = {}): Config => {
  return new Config({
    baseDirs: ["."],
    targets,
    features,
    verbose: false,
    delete: false,
    global: false,
    simulateCommands: false,
    simulateSubagents: false,
    simulateSkills: false,
    modularMcp,
  });
};

describe("gitignoreCommand", () => {
  const mockGitignorePath = "/workspace/.gitignore";

  beforeEach(() => {
    vi.spyOn(process, "cwd").mockReturnValue("/workspace");

    vi.mocked(logger.info).mockImplementation(() => {});
    vi.mocked(logger.success).mockImplementation(() => {});

    vi.mocked(fileExists).mockResolvedValue(false);
    vi.mocked(readFileContent).mockResolvedValue("");
    vi.mocked(writeFileContent).mockResolvedValue(undefined);

    vi.mocked(ConfigResolver.resolve).mockResolvedValue(createMockConfig());
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  describe("when .gitignore does not exist", () => {
    it("should create a new .gitignore with all AI tool rules", async () => {
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      expect(fileExists).toHaveBeenCalledWith(mockGitignorePath);
      expect(readFileContent).not.toHaveBeenCalled();
      expect(writeFileContent).toHaveBeenCalledWith(
        mockGitignorePath,
        expect.stringContaining("# Generated by rulesync - AI tool configuration files"),
      );
      expect(logger.success).toHaveBeenCalledWith(
        expect.stringMatching(/Added \d+ rules to \.gitignore:/),
      );
    });

    it("should include all expected AI tool patterns", async () => {
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toContain("**/.amazonq/");
      expect(content).toContain("**/.cursor/");
      expect(content).toContain("**/.clinerules/");
      expect(content).toContain("**/CLAUDE.md");
      expect(content).toContain("**/.gemini/memories/");
      expect(content).toContain("**/.roo/rules/");
      expect(content).toContain("**/.aiignore");
      expect(content).toContain("**/.mcp.json");
      expect(content).toContain("**/.github/subagents/");
      expect(content).toContain("**/.github/prompts/");
      expect(content).toContain("**/.warp/");
      expect(content).toContain("**/.codex/");
    });

    it("should format content properly with newline at end", async () => {
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toMatch(/\n$/);
      expect(content).toContain("# Generated by rulesync - AI tool configuration files");
    });
  });

  describe("when .gitignore exists but is empty", () => {
    it("should add all rules to empty .gitignore", async () => {
      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue("");

      await gitignoreCommand();

      expect(fileExists).toHaveBeenCalledWith(mockGitignorePath);
      expect(readFileContent).toHaveBeenCalledWith(mockGitignorePath);
      expect(writeFileContent).toHaveBeenCalledWith(
        mockGitignorePath,
        expect.stringContaining("# Generated by rulesync - AI tool configuration files"),
      );
      expect(logger.success).toHaveBeenCalledWith(
        expect.stringMatching(/Added \d+ rules to \.gitignore:/),
      );
    });
  });

  describe("when .gitignore exists with existing content", () => {
    it("should append new rules to existing content", async () => {
      const existingContent = "node_modules/\n*.log\n";
      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(existingContent);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toContain(existingContent.trim());
      expect(content).toContain("# Generated by rulesync - AI tool configuration files");
      expect(content).toMatch(/node_modules\/\n\*\.log\n\n# Generated by rulesync/);
    });

    it("should preserve existing content with proper spacing", async () => {
      const existingContent = "node_modules/\n*.log";
      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(existingContent);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toMatch(/\*\.log\n\n# Generated by rulesync/);
    });
  });

  describe("when some rules already exist", () => {
    it("should only add missing rules", async () => {
      const existingContent = `node_modules/
*.log
# Generated by rulesync - AI tool configuration files
**/.amazonq/
**/.cursor/`;

      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(existingContent);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toContain("node_modules/");
      expect(content).toContain("*.log");

      const amazonqMatches = content.match(/\*\*\/\.amazonq\//g);
      expect(amazonqMatches).toHaveLength(1);

      const cursorMatches = content.match(/\*\*\/\.cursor\//g);
      expect(cursorMatches).toBeDefined();
      expect(cursorMatches).toHaveLength(1);

      expect(content).toContain("**/.clinerules/");
      expect(content).toContain("**/CLAUDE.md");
    });

    it("should report added rules count excludes already existing entries", async () => {
      vi.mocked(fileExists).mockResolvedValue(false);
      await gitignoreCommand();

      const fullAddCall = vi
        .mocked(logger.success)
        .mock.calls.find((call) => typeof call[0] === "string" && call[0].includes("Added"));
      expect(fullAddCall).toBeDefined();
      const fullMatch = fullAddCall![0].match(/Added (\d+) rules/);
      expect(fullMatch).toBeDefined();
      const fullAddedCount = parseInt(fullMatch![1]!, 10);

      vi.clearAllMocks();
      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(
        readFileContent,
      ).mockResolvedValue(`# Generated by rulesync - AI tool configuration files
**/.amazonq/
**/.cursor/
**/.clinerules/`);

      await gitignoreCommand();

      const partialAddCall = vi
        .mocked(logger.success)
        .mock.calls.find((call) => typeof call[0] === "string" && call[0].includes("Added"));
      expect(partialAddCall).toBeDefined();
      const partialMatch = partialAddCall![0].match(/Added (\d+) rules/);
      expect(partialMatch).toBeDefined();
      const partialAddedCount = parseInt(partialMatch![1]!, 10);

      expect(partialAddedCount).toBeLessThan(fullAddedCount);
    });
  });

  describe("when all rules already exist", () => {
    it("should report that .gitignore is up to date", async () => {
      const allRulesContent = `# Generated by rulesync - AI tool configuration files
**/AGENTS.md
**/.agents/
**/.amazonq/
**/.augmentignore
**/.augment/rules/
**/.augment-guidelines
**/CLAUDE.md
**/.claude/memories/
**/.claude/commands/
**/.claude/agents/
**/.claude/skills/
**/.claude/settings.local.json
**/.mcp.json
**/.clinerules/
**/.clineignore
**/.cline/mcp.json
**/.codexignore
**/.codex/
**/.codex/skills/
**/.cursor/
**/.cursorignore
**/GEMINI.md
**/.gemini/memories/
**/.gemini/commands/
**/.gemini/subagents/
**/.gemini/skills/
**/.github/copilot-instructions.md
**/.github/instructions/
**/.github/prompts/
**/.github/subagents/
**/.github/skills/
**/.vscode/mcp.json
**/.junie/guidelines.md
**/.junie/mcp.json
**/.kiro/steering/
**/.aiignore
**/.opencode/memories/
**/.opencode/commands/
**/opencode.json
**/QWEN.md
**/.qwen/memories/
**/.roo/rules/
**/.rooignore
**/.roo/mcp.json
**/.roo/subagents/
**/.warp/
**/WARP.md
**/.windsurf/rules/
!.rulesync/.aiignore`;

      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(allRulesContent);

      await gitignoreCommand();

      expect(logger.success).toHaveBeenCalledWith(".gitignore is already up to date");
      expect(writeFileContent).not.toHaveBeenCalled();
    });
  });

  describe("logging behavior", () => {
    it("should log each added rule (excluding comments)", async () => {
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      expect(logger.success).toHaveBeenCalledWith(
        expect.stringMatching(/Added \d+ rules to \.gitignore:/),
      );

      expect(logger.info).toHaveBeenCalledWith("  **/.amazonq/");
      expect(logger.info).toHaveBeenCalledWith("  **/.cursor/");
      expect(logger.info).toHaveBeenCalledWith("  **/CLAUDE.md");

      expect(logger.info).not.toHaveBeenCalledWith(
        expect.stringContaining("# Generated by rulesync"),
      );
    });

    it("should not log rules that are comments", async () => {
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      const infoLogCalls = vi.mocked(logger.info).mock.calls;

      for (const call of infoLogCalls) {
        if (typeof call[0] === "string") {
          expect(call[0]).not.toMatch(/^\s*#/);
        }
      }
    });
  });

  describe("error handling", () => {
    it("should handle file existence check errors", async () => {
      vi.mocked(fileExists).mockRejectedValue(new Error("Permission denied"));

      await expect(gitignoreCommand()).rejects.toThrow("Permission denied");

      expect(fileExists).toHaveBeenCalledWith(mockGitignorePath);
      expect(readFileContent).not.toHaveBeenCalled();
      expect(writeFileContent).not.toHaveBeenCalled();
    });

    it("should handle file read errors", async () => {
      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockRejectedValue(new Error("Read error"));

      await expect(gitignoreCommand()).rejects.toThrow("Read error");

      expect(fileExists).toHaveBeenCalledWith(mockGitignorePath);
      expect(readFileContent).toHaveBeenCalledWith(mockGitignorePath);
      expect(writeFileContent).not.toHaveBeenCalled();
    });

    it("should handle file write errors", async () => {
      vi.mocked(fileExists).mockResolvedValue(false);
      vi.mocked(writeFileContent).mockRejectedValue(new Error("Write error"));

      await expect(gitignoreCommand()).rejects.toThrow("Write error");

      expect(fileExists).toHaveBeenCalledWith(mockGitignorePath);
      expect(writeFileContent).toHaveBeenCalled();
      expect(logger.success).not.toHaveBeenCalled();
    });
  });

  describe("path handling", () => {
    it("should use correct .gitignore path based on current working directory", async () => {
      const testCwd = "/different/path";
      vi.spyOn(process, "cwd").mockReturnValue(testCwd);
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      expect(fileExists).toHaveBeenCalledWith(`${testCwd}/.gitignore`);
      expect(writeFileContent).toHaveBeenCalledWith(`${testCwd}/.gitignore`, expect.any(String));
    });
  });

  describe("content formatting", () => {
    it("should handle existing content with trailing whitespace", async () => {
      const existingContent = "node_modules/\n*.log   \n   ";
      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(existingContent);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toMatch(/\*\.log\n\n# Generated by rulesync/);
      expect(content).not.toContain("   \n\n");
    });

    it("should ensure proper line separation between existing and new content", async () => {
      const existingContent = "node_modules/";
      vi.mocked(fileExists).mockResolvedValue(true);
      vi.mocked(readFileContent).mockResolvedValue(existingContent);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toMatch(/node_modules\/\n\n# Generated by rulesync/);
    });
  });

  describe("config-aware filtering", () => {
    it("should generate only claudecode rules when targets=[claudecode] features=[rules]", async () => {
      vi.mocked(ConfigResolver.resolve).mockResolvedValue(
        createMockConfig({
          targets: ["claudecode"],
          features: ["rules"],
        }),
      );
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toContain("**/CLAUDE.md");
      expect(content).toContain("**/.claude/memories/");

      expect(content).not.toContain("**/.mcp.json");
      expect(content).not.toContain("**/.claude/commands/");
      expect(content).not.toContain("**/.claude/agents/");
      expect(content).not.toContain("**/.cursor/");
      expect(content).not.toContain("**/.amazonq/");

      // modular-mcp.json is not included when modularMcp is false
      expect(content).not.toContain("**/modular-mcp.json");
      expect(content).toContain("!.rulesync/.aiignore");
    });

    it("should generate all entries when targets=[*] features=[*]", async () => {
      vi.mocked(ConfigResolver.resolve).mockResolvedValue(createMockConfig());
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toContain("**/CLAUDE.md");
      expect(content).toContain("**/.cursor/");
      expect(content).toContain("**/.amazonq/");
      expect(content).toContain("**/.github/copilot-instructions.md");
    });

    it("should generate only header and footer when targets is empty", async () => {
      vi.mocked(ConfigResolver.resolve).mockResolvedValue(
        createMockConfig({
          targets: [],
          features: ["*"],
        }),
      );
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toContain("# Generated by rulesync - AI tool configuration files");
      expect(content).toContain("!.rulesync/.aiignore");

      // modular-mcp.json is not included when modularMcp is false
      expect(content).not.toContain("**/modular-mcp.json");
      expect(content).not.toContain("**/CLAUDE.md");
      expect(content).not.toContain("**/.cursor/");
    });

    it("should handle specific features correctly", async () => {
      vi.mocked(ConfigResolver.resolve).mockResolvedValue(
        createMockConfig({
          targets: ["claudecode"],
          features: ["mcp", "commands"],
        }),
      );
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toContain("**/.mcp.json");
      expect(content).toContain("**/.claude/commands/");

      // settings.local.json is under rules feature, not mcp
      expect(content).not.toContain("**/.claude/settings.local.json");
      expect(content).not.toContain("**/CLAUDE.md");
      expect(content).not.toContain("**/.claude/memories/");
      expect(content).not.toContain("**/.claude/agents/");
    });

    it("should handle multiple targets correctly", async () => {
      vi.mocked(ConfigResolver.resolve).mockResolvedValue(
        createMockConfig({
          targets: ["claudecode", "cursor"],
          features: ["rules"],
        }),
      );
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toContain("**/CLAUDE.md");
      expect(content).toContain("**/.claude/memories/");
      expect(content).toContain("**/.cursor/");

      expect(content).not.toContain("**/.amazonq/");
      expect(content).not.toContain("**/.github/copilot-instructions.md");
    });

    it("should deduplicate patterns correctly", async () => {
      vi.mocked(ConfigResolver.resolve).mockResolvedValue(createMockConfig());
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      const headerMatches = content.match(/# Generated by rulesync - AI tool configuration files/g);
      expect(headerMatches).toHaveLength(1);

      const footerMatches = content.match(/!\.rulesync\/\.aiignore/g);
      expect(footerMatches).toHaveLength(1);
    });

    it("should handle targets with no mapping gracefully", async () => {
      vi.mocked(ConfigResolver.resolve).mockResolvedValue(
        createMockConfig({
          targets: ["antigravity"],
          features: ["rules"],
        }),
      );
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toContain("# Generated by rulesync - AI tool configuration files");
      expect(content).toContain("!.rulesync/.aiignore");
      // modular-mcp.json is not included when modularMcp is false
      expect(content).not.toContain("**/modular-mcp.json");
    });

    it("should include modular-mcp.json when modularMcp is enabled", async () => {
      vi.mocked(ConfigResolver.resolve).mockResolvedValue(
        createMockConfig({
          targets: ["claudecode"],
          features: ["rules"],
          modularMcp: true,
        }),
      );
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).toContain("**/modular-mcp.json");
    });

    it("should not include modular-mcp.json when modularMcp is disabled", async () => {
      vi.mocked(ConfigResolver.resolve).mockResolvedValue(
        createMockConfig({
          targets: ["claudecode"],
          features: ["rules"],
          modularMcp: false,
        }),
      );
      vi.mocked(fileExists).mockResolvedValue(false);

      await gitignoreCommand();

      const writeCall = vi.mocked(writeFileContent).mock.calls[0];
      expect(writeCall).toBeDefined();
      const content = writeCall![1];

      expect(content).not.toContain("**/modular-mcp.json");
    });
  });

});
