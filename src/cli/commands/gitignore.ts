import { join } from "node:path";
import { ConfigResolver } from "../../config/config-resolver.js";
import type { Feature } from "../../types/features.js";
import type { ToolTarget } from "../../types/tool-targets.js";
import { fileExists, readFileContent, writeFileContent } from "../../utils/file.js";
import { logger } from "../../utils/logger.js";

type GitignoreMapping = {
  [K in ToolTarget]?: {
    [F in Feature]?: string[];
  };
};

type CommonGitignoreEntries = {
  header: string[];
  footer: string[];
};

const GITIGNORE_COMMON: CommonGitignoreEntries = {
  header: ["# Generated by rulesync - AI tool configuration files"],
  footer: ["!.rulesync/.aiignore"],
};

const GITIGNORE_MODULAR_MCP = "**/modular-mcp.json";

const GITIGNORE_MAPPING: GitignoreMapping = {
  // AGENTS.md
  agentsmd: {
    rules: ["**/AGENTS.md", "**/.agents/"],
  },

  // Amazon Q CLI
  amazonqcli: {
    rules: ["**/.amazonq/"],
  },

  // Augment Code
  augmentcode: {
    rules: ["**/.augment/rules/"],
    ignore: ["**/.augmentignore"],
  },

  // Augment Code Legacy
  "augmentcode-legacy": {
    rules: ["**/.augment-guidelines"],
  },

  // Claude Code
  claudecode: {
    rules: ["**/CLAUDE.md", "**/.claude/memories/", "**/.claude/settings.local.json"],
    mcp: ["**/.mcp.json"],
    commands: ["**/.claude/commands/"],
    subagents: ["**/.claude/agents/"],
    skills: ["**/.claude/skills/"],
  },

  // Cline
  cline: {
    rules: ["**/.clinerules/"],
    ignore: ["**/.clineignore"],
    mcp: ["**/.cline/mcp.json"],
  },

  // Codex CLI
  codexcli: {
    rules: ["**/.codex/"],
    ignore: ["**/.codexignore"],
    skills: ["**/.codex/skills/"],
  },

  // Cursor
  cursor: {
    rules: ["**/.cursor/"],
    ignore: ["**/.cursorignore"],
  },

  // Gemini CLI
  geminicli: {
    rules: ["**/GEMINI.md", "**/.gemini/memories/"],
    commands: ["**/.gemini/commands/"],
    subagents: ["**/.gemini/subagents/"],
    skills: ["**/.gemini/skills/"],
  },

  // GitHub Copilot
  copilot: {
    rules: ["**/.github/copilot-instructions.md", "**/.github/instructions/"],
    mcp: ["**/.vscode/mcp.json"],
    commands: ["**/.github/prompts/"],
    subagents: ["**/.github/subagents/"],
    skills: ["**/.github/skills/"],
  },

  // Junie
  junie: {
    rules: ["**/.junie/guidelines.md"],
    mcp: ["**/.junie/mcp.json"],
  },

  // Kiro
  kiro: {
    rules: ["**/.kiro/steering/"],
    ignore: ["**/.aiignore"],
  },

  // OpenCode
  opencode: {
    rules: ["**/.opencode/memories/", "**/opencode.json"],
    commands: ["**/.opencode/commands/"],
  },

  // Qwen Code
  qwencode: {
    rules: ["**/QWEN.md", "**/.qwen/memories/"],
  },

  // Roo Code
  roo: {
    rules: ["**/.roo/rules/"],
    ignore: ["**/.rooignore"],
    mcp: ["**/.roo/mcp.json"],
    subagents: ["**/.roo/subagents/"],
  },

  // Warp
  warp: {
    rules: ["**/.warp/", "**/WARP.md"],
  },

  // Windsurf
  windsurf: {
    rules: ["**/.windsurf/rules/"],
  },
};

/**
 * Adds AI tool configuration paths to .gitignore based on rulesync.jsonc configuration.
 *
 * This command respects the `targets` and `features` settings in rulesync.jsonc,
 * generating only the relevant .gitignore entries for the configured tools and features.
 *
 * @example
 * // With rulesync.jsonc: { "targets": ["claudecode"], "features": ["rules"] }
 * // Only adds: CLAUDE.md, .claude/memories/
 *
 * @example
 * // With rulesync.jsonc: { "targets": ["*"], "features": ["*"] }
 * // Adds all AI tool configuration paths
 */
export const gitignoreCommand = async (): Promise<void> => {
  const gitignorePath = join(process.cwd(), ".gitignore");

  // Load configuration to filter entries by targets and features
  const config = await ConfigResolver.resolve({});
  const targets = config.getTargets();
  const features = config.getFeatures();

  // Build entries list based on configured targets and features
  const rulesFilesToIgnore: string[] = [...GITIGNORE_COMMON.header];

  for (const target of targets) {
    const targetMapping = GITIGNORE_MAPPING[target];
    if (!targetMapping) continue;

    for (const feature of features) {
      const patterns = targetMapping[feature];
      if (patterns) {
        rulesFilesToIgnore.push(...patterns);
      }
    }
  }

  // Add modular-mcp.json only if modularMcp is enabled
  if (config.getModularMcp()) {
    rulesFilesToIgnore.push(GITIGNORE_MODULAR_MCP);
  }

  rulesFilesToIgnore.push(...GITIGNORE_COMMON.footer);

  // Remove duplicates while preserving order
  const uniqueEntries = [...new Set(rulesFilesToIgnore)];

  // Read existing .gitignore content
  let gitignoreContent = "";

  if (await fileExists(gitignorePath)) {
    gitignoreContent = await readFileContent(gitignorePath);
  }

  // Filter out entries that already exist in .gitignore
  const linesToAdd: string[] = [];

  for (const rule of uniqueEntries) {
    if (!gitignoreContent.includes(rule)) {
      linesToAdd.push(rule);
    }
  }

  if (linesToAdd.length === 0) {
    logger.success(".gitignore is already up to date");
    return;
  }

  // Append new entries to .gitignore
  const newContent = gitignoreContent
    ? `${gitignoreContent.trimEnd()}\n\n${linesToAdd.join("\n")}\n`
    : `${linesToAdd.join("\n")}\n`;

  await writeFileContent(gitignorePath, newContent);

  logger.success(`Added ${linesToAdd.length} rules to .gitignore:`);
  for (const line of linesToAdd) {
    if (!line.startsWith("#")) {
      logger.info(`  ${line}`);
    }
  }
};
